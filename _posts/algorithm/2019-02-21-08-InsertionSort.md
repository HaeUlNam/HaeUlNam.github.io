---
layout: post
title: 07. 삽입 정렬(Insertion Sort)
category: 자료구조-알고리즘-구현
permalink: /algorithm/:year/:month/:day/:title/
tags: [DataStructure, Algorithm, Sort, QuickSort, nlogn, Randomized]
comments: true
---
<br><br>

## Insertion Sort 설명

* 오름차순 정렬을 기준으로 설명하겠다.

* Insertion Sort 전체 설명
    * index를 2 부터 N까지 움직이고 
    * 각 index 값을 기준값으로 둔다.
    * 기준 값보다 작은 index들을 큰 순서대로 비교해나가면서, 자신보다 작은 숫자가 나오는 순간!! 그 우측에 저장한다.
    * 물론, 기준값과 비교하면서 기준값보다 큰 숫자들은 우측으로 한 칸씩 밀어준다.

* 아래 하나의 예제를 들어서 설명하도록 하겠다.

<center>

55 07 78 12 42 <br>
07 55 78 12 42 <br>

<b>두번째 데이터</b> 07로 비교 시작.<br> 07과 그 앞에 있는 데이터들과 비교하는데, 55보다 07이 작기에 서로 자리를 바꾸는 형태가 된다.<br>

07 55 78 12 42 <br>

<b>세번째 데이터</b> 78로 비교 시작. <br> 78이 55와 비교했더니, 78이 더 크기에 변동이 없다.<br>

07 55 78 12 42<br>
07 55 78 78 42<br>
07 55 55 78 42<br>
07 12 55 78 42<br>

<b>세번째 데이터</b> 12로 비교 시작. <br> 12와 78을 비교하였더니, 78이 더 커서 우측으로 한 칸.<br>
12와 55 비교하였더니, 55가 더 커서 우측으로 한 칸.<br>
12와 07 비교하였더니, 12가 더 커서 멈추고 07 우측에 저장한다.<br>

07 12 55 78 42<br>
07 12 55 78 78<br>
07 12 55 55 78<br>
07 12 42 55 78<br><br>
<b>네번째 데이터</b> 42로 비교 시작. <br> 세번째 데이터 비교했던 것과 같은 로직으로 반복하면, 맨 마지막과 같이 정렬된 결과가 나온다.<br>

</center>

---

## Insertion Sort 시간복잡도

* Worst Case : O(n^2) 
    * 비교 횟수 : 1 + 2 + .... + n-1  = n(n-1)/2

* Average Case : O(n^2)

* Best Case : O(n)
    * 비교 횟수 : n - 1번<br>
    -> 다른 for문을 거칠 필요 없이, n번만 비교하면 되기에 O(n)이다.

---

## 장점


---

## 단점


--- 

## Github 코드

---

* 